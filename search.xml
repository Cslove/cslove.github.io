<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[闭包这个玩意]]></title>
    <url>%2F%E9%97%AD%E5%8C%85%E8%BF%99%E4%B8%AA%E7%8E%A9%E6%84%8F.html</url>
    <content type="text"><![CDATA[闭包这个东西让我理解了好久，也算是理解javascript语言比较重要的一个环节吧，在这做一个自我思考的详细总结~，有错误望指正~ 首先要说明的是闭包在你的代码中随处可见，可能不知不觉的你正在写闭包~，只是你不认识它，不了解它，现在我们揭开它的面纱来瞧瞧它的真面目。 先说下闭包直截了当的定义，我也是在网上查了下：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行来看下代码: 12345678function foo()&#123; var a=2; function fee()&#123; console.log(a); &#125; fee();&#125;foo(); 这段代码应该很好懂了，我们是不是也经常在写，fee函数可以访问foo作用域内的变量a，但上面那个是闭包吗，严格来说不算是，闭包总是隐藏在代码之后的，他总是不那么容易发现。看如下代码：123456789function foo()&#123; var a=2; function fee()&#123; console.log(a); &#125; return fee;&#125;var b=foo();b(); //2上面的代码就是所谓的闭包，我们将fee函数当成一个值类型进行传递，然后在外界通过调用foo函数在给b，通过不同的标识符引用调用了内部的函数fee（）。而且fee函数 也在作用域之外被执行了，也符合上面的定义。 闭包的神奇之处在阻止作用域被销毁，看上面的代码，看上去foo的内容不会再调用，其实内部 的fee函数拥有它的作用域闭包，使得该作用域能一直存活，以便fee能在任何时间引用。 从上面的代码我觉得最重要的一点就是，可以对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。 12345678910function foo()&#123; var a=2; function fee()&#123; console.log(a); &#125; boo(fee);&#125;function boo(fn)&#123; fn();&#125; 上面也是一种闭包，将fee函数当成参数值传递到boo中，然后在外界的boo函数中执行了它，当然也能访问到a了。在看下面的形式：12345678910111213var fn;function foo()&#123; var a=2; function fee()&#123; console.log(a); &#125; fn=fee;&#125;;function boo()&#123; fn();&#125;;foo();boo(); //2上面的也是闭包，无论通过何种手段将内部函数传递到所在的词法作用域以外，他都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。 现在我们可以发现闭包在我们的程序中到处可见了吧，比如下面的那个：123456function foo(a)&#123; setTimeout(function timer()&#123; console.log(a); &#125;,1000)&#125; foo(1); //1秒后打印1将一个timer函数当为参数传递给了setTimeout内，timer具有涵盖foo作用域的闭包，因此能访问到a。 so ，这就是闭包！在javascript中到处可见，定时器，时间监听器，Ajax请求，或者其他异步请求的回调函数就是在使用闭包！ 我们在看下立即执行函数（可以看我的这篇文章：js函数作用域与块作用域）：1234var a=2;(function()&#123; console.log(a);&#125;)();这个是不是闭包呢，我觉得不严格是，因为它不是在词法作用域之外执行的，在定义时就执行了，不过它确实是访问了a，也就是创建了闭包，它也常常是创建可以被封闭起来的工具。 闭包在循环中也有很大的应用，es6中的模块机制也都是使用闭包。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大三期末的思考：改变是一堂必修课~]]></title>
    <url>%2F%E5%A4%A7%E4%B8%89%E6%9C%9F%E6%9C%AB%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%9A%E6%94%B9%E5%8F%98%E6%98%AF%E4%B8%80%E5%A0%82%E5%BF%85%E4%BF%AE%E8%AF%BE.html</url>
    <content type="text"><![CDATA[唉呀妈呀，转眼就要大四了~意味着16年的学生生涯即将终止！啊？还有研究生涯呢！额…抱歉~我不打算考研^O^不过回忆大学这三年觉得“改变”真的是一堂必修课！最近打LOL和一妹子开黑，额…不能说是妹子！算是个小学姐吧~因为她比我大一届，是今年毕业的。在开黑语音聊天问到她大学谈没谈过恋爱时，她就开始了独属于她的那段珍贵的回忆…她有个亲哥哥，所以从小就很受宠。在现在这个年代里，被从小惯到大多少有点公主病的。只是没想到她的公主病有点严重…她大学里谈了两次恋爱，第一次在大一有一个男生追的她，大一嘛，都是懵懂无知的小崽子，初尝到恋爱滋味了就陷得无法自拔了~不过越往后她的公主病来了，好像男方必须做什么事都得围着她转，尤其她说的一个情景让我很吃惊。她带着她的男友和舍友们一起出去吃饭，仅仅因为男方没有帮她打开筷子，直接拿起包走了，留下一桌尴尬的人…不久她提出了分手~ 第二次恋爱是她追的一个男生，对于这个男生倒没听她多说什么，不过我觉得他应该是个暖男，因为他对她很好，而这也刚好符合她。她们相处了两年分了……听她说是因为男方对她的宠使得她的公主病病到不可收拾的地步，任何一件事只要不符合她的意愿就会找架吵。在大三暑假尤其吵得凶，最后她赌气说分手，结果就真分了…她怎么会去挽留？而男方也许也已到了极致了。在这之后的时间里她很痛苦，有过后悔说分手，公主病尤其到了极致…就因为舍友忘了帮她打水，她一周都没跟那位舍友说话！所有人都不敢和她交流了。 在那之后的日子里，她开始思考了，思考自己的问题所在，思考自己往后的人生。其实和她第一次语音开黑时听声音觉得对方是个挺活泼健谈的女孩，谁可知那是改变以后的她。毕业的那几天她舍友说她是改变最大的那个，她也说很感谢当初那个促使她改变的那个人，那个她第二次恋爱的人。对于未来她充满了斗志，一个人去了上海打拼找工作，回到家她妈妈还催她以后要找个什么样男友，她却霸道的对我说30岁了都不急，我自己能养活自己何必找个男的呢… 改变~就在你的一念之间。或许你会说只有经历了重大变故的人才能彻彻底底改变，就比如上面的她？不可否认，我也觉得当一个人受到极大的刺激才能彻底的改变，可我们都只是个正常人，做着正常的事而已，哪来的变故与刺激使我们彻底改变？但亲爱的，我们为什么要彻底的改变？我们可不可以学着从一件小事改变呢，或者改变一些小习惯呢。例如，每天玩王者荣耀是你必须做的，那你能不能试着改变下做到每天只玩1个小时，剩下的原来游戏时间试着去写篇文章或者画一幅画？改变就在你的一念之间，或许这一念之间是最困难的，很自然的我们会被正在做的事忘记时间，忘记自我。等到最后才发出一声长叹，哎嘘~又浪费了这么长的时间。所以，可以的话给你的手机设个闹钟提醒自己时间到了，是时候该做出改变了~ 哎嘘，感觉说了挺多废话的。说是容易，做的话难于上青天~不过以我现有的观察来看，当一个人做出改变时往往是自己独处的时候。海蓝博士也说过当你有情绪的时候，找一个安静的地方放松自己与自己进行对话并以实际行动解决当下。长写文章就是个与自己对话的好方式~写到这我也觉得该时常更新我的博客了！不管怎样，最主要是为了在内心遇见更好的自己~ 大三期末总结至此over~都说出了社会我们会变成自己所讨厌的那种人，期待ing~]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[无Hack实现CSS三角形]]></title>
    <url>%2F%E6%97%A0Hack%E5%AE%9E%E7%8E%B0CSS%E4%B8%89%E8%A7%92%E5%BD%A2.html</url>
    <content type="text"><![CDATA[在使用HTML/CSS编写页面的人都知道，为了创建一个只有CSS的三角形或者那些带有尖尖形状的元素都需要一些hack写法，典型两种比较受欢迎的解决方案就是充分使用border属性和使用Unicode字符。在这里我们先讲解下使用border属性怎样实现CSS三角形。 border属性我们先来看下用这个方式所实现的代码：1&lt;div id="triangle-up"&gt;&lt;/div&gt;1234567#triangle-up &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red;&#125;以上代码运行的结果是这样的：充分利用了border属性，我们知道设置border时它的边框是以45°角相互对接的，就像这样：首先设置了其content宽高为0，不用设置上边框，设置底部边框一个长度，然后就是设置左右边框的宽度为底部的一半并设置左右边框颜色透明，得到了一个等腰三角形。具体原理可以看这里。 可以看到使用这些hack写法太死板了，很不灵活，例如我们不能设置三角形的颜色，因为其内容宽高为0.接下来我们来看下无hack实现CSS三角形。 Clip-pathClip-path是CSS规范中的一个新的补充，它允许我们只显示一部分元素并隐藏其余元素。我们来看下它的工作原理：1&lt;div&gt;&lt;/div&gt;12345678div &#123; width: 200px; height: 200px; background: red; /* The points are: centered top, left bottom, right bottom */ clip-path: polygon(50% 0, 0 100%, 100% 100%);&#125;显示结果形状与上栗一样，可以看到我们需要一个polygon函数，要实现三角形需要三个点，我们先指定了div的宽高，这也是其重点，因为这样内容区域背景色我们就可以随心定制自己想要的，甚至也可以是图片。接下来可以看到在clip-path属性上调用polygon函数并给出了三个点的坐标，即三角形的上顶点和下面左右点的坐标，在图形定制方面就更加灵活了，我们可以实现各种各样的形状，拥有强大的灵活性。想要更多的形状实现可以参考这里 浏览器支持这个属性在Chrome中完美支持，ie就不用说了，并不支持，期待IE的未来吧。Safari需要使用-webkit-前缀，Firefox用户必须等到版本53。 更多内容请看这里 Danny Markovhttps://tutorialzine.com/2017/03/css-triangles-without-hacks]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>HTML/CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是作用域及js编译原理]]></title>
    <url>%2F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8Ajs%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.html</url>
    <content type="text"><![CDATA[每个程序语言都会有对变量的使用，会对这个变量就行赋值修改等操作。那么问题来了，这些变量都存在哪里，怎样对它进行查找并读取呢？显然，我们必须定义一套规则来操作这些变量简单的进行读取和存储，而这套规则应该就是作用域了。来看一个简单的赋值语句var a=2; 大多数人会认为这是一个声明变量并赋值而已，事实也确实如此，而要强调的是电脑中的引擎会将它认为是两个声明，第一个var a 看做是在编译器编译时处理，一个是a=2 在引擎运行时处理。通俗的话在概括下就是：为一个变量分配内存，将其命名为a，然后将值2保存进这个变量。当然在编译阶段还有很多任务要做，比如还要查看当前作用域是否声明过此变量等一系列问题。 来看一下如下简单代码： var a=2; console.log(a); 引擎是如何处理这段代码的呢？在当前作用域（当前也就是全局作用域）中，引擎会为变量a进行LHS查询和RHS查询。上面的代码var a=2; 会对a进行LHS查询，LHS查询也就是赋值操作的目标是谁。console.log(a) 中会对a进行RHS查询，可以这样理解RHS查询：谁是赋值操作的源头，也就是说这个变量a的源头是谁（值是谁），这里明显就是2了。 为什么要区分LHS和RHS查询呢？因为在变量还为声明的时候，这两种查询的行为不一样。来看如下代码： function foo(a){ console.log(b); //ReferenceError } foo(2); 可以看到在对b进行RHS查询时，变量b并未声明，此时引擎在当前作用域未找到变量b，然后会在外层作用域查找（此时为全局作用域），外层作用域都没有此变量，就会发生常见的ReferenceError。 而在看LHS查询，当LHS查询在此作用域和外层作用域都没有查找到此变量，全局作用域就会自动创建一个此变量，前提是在非严格模式下，如果在严格模式下会报ReferenceError。在ES5中引入的严格模式与正常模式相比在行为上有许多的不同。接下来若查找到此变量，而你要是对此变量做一些不合理的操作就会报TypeError错误。 在来看作用域，看如下代码： function foo(a){ console.log(a+b); } var b=2; foo(2); //4 可以看到引擎在执行foo函数作用域内的语句console.log（a+b）时b变量并未在此作用域内，而最后还是能输出4，从上面的讲述也已经提到了当引擎未在当前作用域查找到变量就会在它的上层作用域一层层的查找。而上面我们所手写的作用域叫做词法作用域，引擎在查找变量时会从内部的作用域一层层想外展开来，相应的如果内层的作用域中的变量与外层作用域声明的变量标识符一样的话，内部变量会覆盖外层的，但如果外层作用域是全局作用域可以通过Window.x 来访问，x为相应的变量标识符。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>