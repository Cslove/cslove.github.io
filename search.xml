<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅析深拷贝与浅拷贝js实现]]></title>
    <url>%2F2017%2F08%2F09%2F%E6%B5%85%E6%9E%90%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9Djs%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[最近研究了下jQuery源码中extend的实现，里面涉及了深拷贝与浅拷贝，在这里简单的做个总结。 首先深浅拷贝主要是拷贝Object这种复杂类型的值，例如常见的Array，常见的Json数据，顺便提一下也可以用JSON.parse()和JSON.stringify()来进行深拷贝。 浅拷贝两个对象指向了同一块内存，修该其中的任意值，另一个值都会随之变化，这就是浅拷贝，先来看下一个简单的代码实现： 123456var a =&#123; name:"niaho" &#125;;var b =a;b.name = 'hello';console.log(a.name,b.name) // hello hello 可以看到改变b的name属性值，相应的a的name属性值也改变了，这就是浅拷贝，这种针对对象的赋值都是引用传递，有一个新方法也可以实现这种钱拷贝，Object.assign()用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象：123456789101112var a = &#123; c:1, b:2, e:&#123;foo:3,bar:4&#125;&#125;;var aa = &#123; c:3, b:4, e:&#123;fee:5,baz:6&#125;&#125;;var src = Object.assign(a,aa);console.log(src) // &#123;c:3,b:4,e:&#123;fee:5,baz:6&#125;&#125;可以看到e是一个引用类型的值，Object.assign()也只是拷贝了那个引用值，所以它也就只能用与拷贝或是合并对象。在下面会说下Jquery的extend中浅拷贝的实现 深拷贝下面来说下复杂点的深拷贝，如果给b放到新的内存中，将a的各个属性都复制到新内存里，就是深拷贝。也就是说，当b中的属性有变化的时候，a内的属性不会发生变化。首先用jQuery中的extend来拷贝上面的例子看下与浅拷贝有什么不一样的地方：12345678910111213141516var a = &#123; c:1, b:2, e:&#123;foo:3,bar:4&#125;&#125;;var aa = &#123; c:3, b:4, e:&#123;fee:5,baz:6&#125;&#125;;var src = $.extend(true,a,aa);console.log(src) // &#123;c:3,b:4,e:&#123;foo:3,bar:4,fee:5,baz:6&#125;&#125;var content = $.extend(a,aa);console.log(content) // &#123;c:3,b:4,e:&#123;fee:5,baz:6&#125;&#125;jQuery.extend( [deep ], target, object1 [, objectN ] )，其中deep为Boolean类型，如果是true，则进行深拷贝,如果是false就是浅拷贝。通过上面的对比我们就可以看到当使用extend()进行深拷贝的时候，对象的所有属性都添加到target中了。像之前说的我们也可以用JSON的parse和stringify方法简单的实现上面的拷贝：12345678910var a = &#123; c:1, b:2, e:&#123;foo:3,bar:4&#125;&#125;;var src = JSON.parse(JSON.stringify(a));src.c = 2;console.log(src,a) // &#123;b:2,c:2,e:&#123;bar:4,foo:3&#125;&#125; &#123;b:2,c:1,e:&#123;bar:4,foo:3&#125;&#125;可以看到将拷贝后的src对象改变它的c属性值影响不到a里面的c值了，完全是两个对象。但这个方法有局限性，它拷贝的只能是JSON结构的数据，有些对象的属性值是一个function函数，它就拷贝不了了，而jQuery的extend方法就都可以，下面我们来看下jQuery的extend方法源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566jQuery.extend = jQuery.fn.extend = function() &#123; var options, name, src, copy, copyIsArray, clone, target = arguments[ 0 ] || &#123;&#125;, i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if ( typeof target === "boolean" ) &#123; deep = target; // Skip the boolean and the target target = arguments[ i ] || &#123;&#125;; i++; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== "object" &amp;&amp; !jQuery.isFunction( target ) ) &#123; target = &#123;&#125;; &#125; // Extend jQuery itself if only one argument is passed if ( i === length ) &#123; target = this; i--; &#125; for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( ( options = arguments[ i ] ) != null ) &#123; // Extend the base object for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) &#123; continue; &#125; // Recurse if we're merging plain objects or arrays if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || ( copyIsArray = Array.isArray( copy ) ) ) ) &#123; if ( copyIsArray ) &#123; copyIsArray = false; clone = src &amp;&amp; Array.isArray( src ) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don't bring in undefined values &#125; else if ( copy !== undefined ) &#123; target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;;看着有点长，我们一步步来进行解剖，首先它取得了第一个参数值并把它赋值给了target变量，并判断它是否是一个布尔值，如果是的话就把它赋值给deep变量，也就是我们前面所说的那个deep，然后取得了第二个参数的值赋值给target，否则的话就直接判断target是对象还是函数，都不是的话就置为一个{}，接下来就是判断如果extend参数只有一个参数值就把jquery本身赋值给target，接下来就是一个for循环遍历给extend传递的参数对象，src是最终要返回的对象的属性值，而copy是被复制的对象的属性值，再就是判断deep变量进行深浅拷贝的问题如果是浅拷贝就直接把copy赋值给target[name]并返回target，主要就是里面的深拷贝，它进一步判断copy是不是一个对象或者数组，也就是我们前面说的要被复制的对象的属性值是一个引用类型的值，就把src赋给clone变量在递归调用extend方法并将clone和copy当为参数传递进去，也就是将引用类型的值当为一个新对象在进行拆解拷贝，最后返回target就是深拷贝后的值了]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6模块与CommonJS模块]]></title>
    <url>%2F2017%2F07%2F27%2FES6%E6%A8%A1%E5%9D%97%E4%B8%8ECommonJS%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[不知道浏览器端的es6模块功能什么时候能够完全支持…不过貌似最新的谷歌浏览器对于模块功能还在实验性功能阶段，希望可以早早完全支持。毕竟使用模块化的编程还是挺爽的，以前都是使用自执行的匿名函数和闭包创建一个封闭的作用域，最麻烦的感觉就是要把这些脚本文件一个个用script标签贴在html页面上，结果一个页面下来几十个script标签都是很正常，虽然有webpack这种打包工具可以让这些自动执行，但毕竟还是有学习成本…尤其那个webpack配置还是比较麻烦的0-0，所以还是很期待在浏览器端的es6模块功能的，不过使用一些垫片库也可以使用es6模块的，例如systemJS:1234567891011// app/es6-file.js:export class q &#123; constructor() &#123; this.es6 = 'hello'; &#125;&#125;// 在网页中加载这个文件System.import('app/es6-file').then(function(m) &#123; console.log(new m.q().es6); // hello&#125;); 说到es6模块就不得不说CommonJS模块规范，nodeJS主要实现了此规范，说到nodeJS觉得它最强大的就是npm package包管理器，和基于此它那强大的npm包生态系统，在github上有几十万个npm包…绝对的霸主地位。 ES6模块在浏览器端的实现因为浏览器的默认语言是javascript所以我们引入js文件可以省略type属性，比如这样：123&lt;script type="text/javascript" src="./foo.js"&gt;&lt;/script&gt;&lt;!--可以写成下面这样--&gt;&lt;script src="./foo.js"&gt;&lt;/script&gt;而如果我们想将foo.js文件写成一个es6模块就必须把type属性设置为module1&lt;script type="module" src="./foo.js"&gt;&lt;/script&gt;这样就可以在foo.js中引入其他模块，使用import语句，而且这个时候也会异步加载这个foo.js文件，也就是说把这个script标签放在head标签内，浏览器在加载这个页面的时候会异步下载这个foo文件，等页面全部渲染完后才会执行这个js文件。要是在以前的script标签会阻塞页面的渲染必须等下载完js文件然后执行它才会开始渲染页面，而这整个时期页面是完全空白的，用户体验就会很差，所以一些最好的实践就是把script标签放在body的最后，等页面渲染完在执行js。不过在现在的一些单页面应用又有一些不同，以后会提~ node中的es6模块与commonJS模块nodeJS是javascript在服务器端的实现，它遵循的是CommonJS模块规范，而相应的es6模块也在node中可以实现，而弄清这两者的区别就挺重要的。 首先这两者有两个最主要的区别：1.es6模块是引入的值得引用，CommonJS是值得传递2.CommonJS是运行时加载，es6是在编译的时候输出接口 下面来解释下第一条区别，先来看一下CommonJS的代码：lib.js12345678var a = 3;function incCounter() &#123; a++;&#125;module.exports = &#123; a: a, Counter: incCounter,&#125;;上面代码输出了a变量和一个改变a的函数，我们在另一个文件中引入它：main.js12345var foo = require('./lib');console.log(foo.a); // 3foo.Counter();console.log(foo.a); // 3上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的foo.a了。这是因为foo.a是一个原始类型的值，会被缓存。在来看下es6模块的代码：lib.js1234export var a = 3;export function incCounter() &#123; a++;&#125;main.js1234import &#123;a,incCounter&#125; from "./lib.js"console.log(a); // 3incCounter(); console.log(a); //4上面代码说明，ES6 模块输入的变量a是活的，完全反应其所在模块lib.js内部的变化。 在node中es6模块与commonJS模块可以互相加载对方，es6模块使用import加载commonJS的模块文件时会将commonJS模块文件的module.exports对象看作是export default，也就是说把default属性看做了module.exports，来看下代码： 12345678// foo.jsmodule.exports=&#123; a:1&#125;//bar.jsimport bar from "./foo.js";bar.a //1 而如果commonJS模块文件加载es6模块文件会将export的输出接口直接作为输入接口的属性，而且是作为值属性，在运行时加载过一次模块，就会将值缓存，下次在执行require就会从缓存中取值。12345678910// foo.jsexport var a = 1;export function baz()&#123; console.log(a)&#125;//bar.jsvar bar = require("./foo.js");bar.a //1bar.baz() //1ES6模块与CommonJS模块有关循环加载问题有区别，主要就是因为es6是静态编译阶段的引用传递，而commonJS是在运行时加载的缓存值得输出，所以在有些循环加载的问题上往往commonJS模块在有些时候会报出undefined或者报错，因为在运行阶段取不到该去的值。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包这个玩意]]></title>
    <url>%2F2017%2F07%2F09%2F%E9%97%AD%E5%8C%85%E8%BF%99%E4%B8%AA%E7%8E%A9%E6%84%8F%2F</url>
    <content type="text"><![CDATA[闭包这个东西让我理解了好久，也算是理解javascript语言比较重要的一个环节吧，在这做一个自我思考的详细总结~，有错误望指正~ 首先要说明的是闭包在你的代码中随处可见，可能不知不觉的你正在写闭包~，只是你不认识它，不了解它，现在我们揭开它的面纱来瞧瞧它的真面目。 先说下闭包直截了当的定义，我也是在网上查了下：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行来看下代码: 12345678function foo()&#123; var a=2; function fee()&#123; console.log(a); &#125; fee();&#125;foo(); 这段代码应该很好懂了，我们是不是也经常在写，fee函数可以访问foo作用域内的变量a，但上面那个是闭包吗，严格来说不算是，闭包总是隐藏在代码之后的，他总是不那么容易发现。看如下代码：123456789function foo()&#123; var a=2; function fee()&#123; console.log(a); &#125; return fee;&#125;var b=foo();b(); //2上面的代码就是所谓的闭包，我们将fee函数当成一个值类型进行传递，然后在外界通过调用foo函数在给b，通过不同的标识符引用调用了内部的函数fee（）。而且fee函数 也在作用域之外被执行了，也符合上面的定义。 闭包的神奇之处在阻止作用域被销毁，看上面的代码，看上去foo的内容不会再调用，其实内部 的fee函数拥有它的作用域闭包，使得该作用域能一直存活，以便fee能在任何时间引用。 从上面的代码我觉得最重要的一点就是，可以对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。 12345678910function foo()&#123; var a=2; function fee()&#123; console.log(a); &#125; boo(fee);&#125;function boo(fn)&#123; fn();&#125; 上面也是一种闭包，将fee函数当成参数值传递到boo中，然后在外界的boo函数中执行了它，当然也能访问到a了。在看下面的形式：12345678910111213var fn;function foo()&#123; var a=2; function fee()&#123; console.log(a); &#125; fn=fee;&#125;;function boo()&#123; fn();&#125;;foo();boo(); //2上面的也是闭包，无论通过何种手段将内部函数传递到所在的词法作用域以外，他都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。 现在我们可以发现闭包在我们的程序中到处可见了吧，比如下面的那个：123456function foo(a)&#123; setTimeout(function timer()&#123; console.log(a); &#125;,1000)&#125; foo(1); //1秒后打印1将一个timer函数当为参数传递给了setTimeout内，timer具有涵盖foo作用域的闭包，因此能访问到a。 so ，这就是闭包！在javascript中到处可见，定时器，时间监听器，Ajax请求，或者其他异步请求的回调函数就是在使用闭包！ 我们在看下立即执行函数（可以看我的这篇文章：js函数作用域与块作用域）：1234var a=2;(function()&#123; console.log(a);&#125;)();这个是不是闭包呢，我觉得不严格是，因为它不是在词法作用域之外执行的，在定义时就执行了，不过它确实是访问了a，也就是创建了闭包，它也常常是创建可以被封闭起来的工具。 闭包在循环中也有很大的应用，es6中的模块机制也都是使用闭包。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大三期末的思考：改变是一堂必修课~]]></title>
    <url>%2F2017%2F07%2F03%2F%E5%A4%A7%E4%B8%89%E6%9C%9F%E6%9C%AB%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%9A%E6%94%B9%E5%8F%98%E6%98%AF%E4%B8%80%E5%A0%82%E5%BF%85%E4%BF%AE%E8%AF%BE%2F</url>
    <content type="text"><![CDATA[唉呀妈呀，转眼就要大四了~意味着16年的学生生涯即将终止！啊？还有研究生涯呢！额…抱歉~我不打算考研^O^不过回忆大学这三年觉得“改变”真的是一堂必修课！最近打LOL和一妹子开黑，额…不能说是妹子！算是个小学姐吧~因为她比我大一届，是今年毕业的。在开黑语音聊天问到她大学谈没谈过恋爱时，她就开始了独属于她的那段珍贵的回忆…她有个亲哥哥，所以从小就很受宠。在现在这个年代里，被从小惯到大多少有点公主病的。只是没想到她的公主病有点严重…她大学里谈了两次恋爱，第一次在大一有一个男生追的她，大一嘛，都是懵懂无知的小崽子，初尝到恋爱滋味了就陷得无法自拔了~不过越往后她的公主病来了，好像男方必须做什么事都得围着她转，尤其她说的一个情景让我很吃惊。她带着她的男友和舍友们一起出去吃饭，仅仅因为男方没有帮她打开筷子，直接拿起包走了，留下一桌尴尬的人…不久她提出了分手~ 第二次恋爱是她追的一个男生，对于这个男生倒没听她多说什么，不过我觉得他应该是个暖男，因为他对她很好，而这也刚好符合她。她们相处了两年分了……听她说是因为男方对她的宠使得她的公主病病到不可收拾的地步，任何一件事只要不符合她的意愿就会找架吵。在大三暑假尤其吵得凶，最后她赌气说分手，结果就真分了…她怎么会去挽留？而男方也许也已到了极致了。在这之后的时间里她很痛苦，有过后悔说分手，公主病尤其到了极致…就因为舍友忘了帮她打水，她一周都没跟那位舍友说话！所有人都不敢和她交流了。 在那之后的日子里，她开始思考了，思考自己的问题所在，思考自己往后的人生。其实和她第一次语音开黑时听声音觉得对方是个挺活泼健谈的女孩，谁可知那是改变以后的她。毕业的那几天她舍友说她是改变最大的那个，她也说很感谢当初那个促使她改变的那个人，那个她第二次恋爱的人。对于未来她充满了斗志，一个人去了上海打拼找工作，回到家她妈妈还催她以后要找个什么样男友，她却霸道的对我说30岁了都不急，我自己能养活自己何必找个男的呢… 改变~就在你的一念之间。或许你会说只有经历了重大变故的人才能彻彻底底改变，就比如上面的她？不可否认，我也觉得当一个人受到极大的刺激才能彻底的改变，可我们都只是个正常人，做着正常的事而已，哪来的变故与刺激使我们彻底改变？但亲爱的，我们为什么要彻底的改变？我们可不可以学着从一件小事改变呢，或者改变一些小习惯呢。例如，每天玩王者荣耀是你必须做的，那你能不能试着改变下做到每天只玩1个小时，剩下的原来游戏时间试着去写篇文章或者画一幅画？改变就在你的一念之间，或许这一念之间是最困难的，很自然的我们会被正在做的事忘记时间，忘记自我。等到最后才发出一声长叹，哎嘘~又浪费了这么长的时间。所以，可以的话给你的手机设个闹钟提醒自己时间到了，是时候该做出改变了~ 哎嘘，感觉说了挺多废话的。说是容易，做的话难于上青天~不过以我现有的观察来看，当一个人做出改变时往往是自己独处的时候。海蓝博士也说过当你有情绪的时候，找一个安静的地方放松自己与自己进行对话并以实际行动解决当下。长写文章就是个与自己对话的好方式~写到这我也觉得该时常更新我的博客了！不管怎样，最主要是为了在内心遇见更好的自己~ 大三期末总结至此over~都说出了社会我们会变成自己所讨厌的那种人，期待ing~]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[无Hack实现CSS三角形]]></title>
    <url>%2F2017%2F07%2F02%2F%E6%97%A0Hack%E5%AE%9E%E7%8E%B0CSS%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[在使用HTML/CSS编写页面的人都知道，为了创建一个只有CSS的三角形或者那些带有尖尖形状的元素都需要一些hack写法，典型两种比较受欢迎的解决方案就是充分使用border属性和使用Unicode字符。在这里我们先讲解下使用border属性怎样实现CSS三角形。 border属性我们先来看下用这个方式所实现的代码：1&lt;div id="triangle-up"&gt;&lt;/div&gt;1234567#triangle-up &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red;&#125;以上代码运行的结果是这样的：充分利用了border属性，我们知道设置border时它的边框是以45°角相互对接的，就像这样：首先设置了其content宽高为0，不用设置上边框，设置底部边框一个长度，然后就是设置左右边框的宽度为底部的一半并设置左右边框颜色透明，得到了一个等腰三角形。具体原理可以看这里。 可以看到使用这些hack写法太死板了，很不灵活，例如我们不能设置三角形的颜色，因为其内容宽高为0.接下来我们来看下无hack实现CSS三角形。 Clip-pathClip-path是CSS规范中的一个新的补充，它允许我们只显示一部分元素并隐藏其余元素。我们来看下它的工作原理：1&lt;div&gt;&lt;/div&gt;12345678div &#123; width: 200px; height: 200px; background: red; /* The points are: centered top, left bottom, right bottom */ clip-path: polygon(50% 0, 0 100%, 100% 100%);&#125;显示结果形状与上栗一样，可以看到我们需要一个polygon函数，要实现三角形需要三个点，我们先指定了div的宽高，这也是其重点，因为这样内容区域背景色我们就可以随心定制自己想要的，甚至也可以是图片。接下来可以看到在clip-path属性上调用polygon函数并给出了三个点的坐标，即三角形的上顶点和下面左右点的坐标，在图形定制方面就更加灵活了，我们可以实现各种各样的形状，拥有强大的灵活性。想要更多的形状实现可以参考这里 浏览器支持这个属性在Chrome中完美支持，ie就不用说了，并不支持，期待IE的未来吧。Safari需要使用-webkit-前缀，Firefox用户必须等到版本53。 更多内容请看这里 Danny Markovhttps://tutorialzine.com/2017/03/css-triangles-without-hacks]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>HTML/CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是作用域及js编译原理]]></title>
    <url>%2F2017%2F07%2F01%2F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8Ajs%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[每个程序语言都会有对变量的使用，会对这个变量就行赋值修改等操作。那么问题来了，这些变量都存在哪里，怎样对它进行查找并读取呢？显然，我们必须定义一套规则来操作这些变量简单的进行读取和存储，而这套规则应该就是作用域了。来看一个简单的赋值语句var a=2; 大多数人会认为这是一个声明变量并赋值而已，事实也确实如此，而要强调的是电脑中的引擎会将它认为是两个声明，第一个var a 看做是在编译器编译时处理，一个是a=2 在引擎运行时处理。通俗的话在概括下就是：为一个变量分配内存，将其命名为a，然后将值2保存进这个变量。当然在编译阶段还有很多任务要做，比如还要查看当前作用域是否声明过此变量等一系列问题。 来看一下如下简单代码： var a=2; console.log(a); 引擎是如何处理这段代码的呢？在当前作用域（当前也就是全局作用域）中，引擎会为变量a进行LHS查询和RHS查询。上面的代码var a=2; 会对a进行LHS查询，LHS查询也就是赋值操作的目标是谁。console.log(a) 中会对a进行RHS查询，可以这样理解RHS查询：谁是赋值操作的源头，也就是说这个变量a的源头是谁（值是谁），这里明显就是2了。 为什么要区分LHS和RHS查询呢？因为在变量还为声明的时候，这两种查询的行为不一样。来看如下代码： function foo(a){ console.log(b); //ReferenceError } foo(2); 可以看到在对b进行RHS查询时，变量b并未声明，此时引擎在当前作用域未找到变量b，然后会在外层作用域查找（此时为全局作用域），外层作用域都没有此变量，就会发生常见的ReferenceError。 而在看LHS查询，当LHS查询在此作用域和外层作用域都没有查找到此变量，全局作用域就会自动创建一个此变量，前提是在非严格模式下，如果在严格模式下会报ReferenceError。在ES5中引入的严格模式与正常模式相比在行为上有许多的不同。接下来若查找到此变量，而你要是对此变量做一些不合理的操作就会报TypeError错误。 在来看作用域，看如下代码： function foo(a){ console.log(a+b); } var b=2; foo(2); //4 可以看到引擎在执行foo函数作用域内的语句console.log（a+b）时b变量并未在此作用域内，而最后还是能输出4，从上面的讲述也已经提到了当引擎未在当前作用域查找到变量就会在它的上层作用域一层层的查找。而上面我们所手写的作用域叫做词法作用域，引擎在查找变量时会从内部的作用域一层层想外展开来，相应的如果内层的作用域中的变量与外层作用域声明的变量标识符一样的话，内部变量会覆盖外层的，但如果外层作用域是全局作用域可以通过Window.x 来访问，x为相应的变量标识符。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>