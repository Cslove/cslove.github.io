<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[无Hack实现CSS三角形]]></title>
    <url>%2F2017%2F07%2F02%2F%E6%97%A0Hack%E5%AE%9E%E7%8E%B0CSS%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[在使用HTML/CSS编写页面的人都知道，为了创建一个只有CSS的三角形或者那些带有尖尖形状的元素都需要一些hack写法，典型两种比较受欢迎的解决方案就是充分使用border属性和使用Unicode字符。在这里我们先讲解下使用border属性怎样实现CSS三角形。 border属性我们先来看下用这个方式所实现的代码：1&lt;div id="triangle-up"&gt;&lt;/div&gt;1234567#triangle-up &#123; width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red;&#125;以上代码运行的结果是这样的：充分利用了border属性，我们知道设置border时它的边框是以45°角相互对接的，就像这样：首先设置了其content宽高为0，不用设置上边框，设置底部边框一个长度，然后就是设置左右边框的宽度为底部的一半并设置左右边框颜色透明，得到了一个等腰三角形。具体原理可以看这里。 可以看到使用这些hack写法太死板了，很不灵活，例如我们不能设置三角形的颜色，因为其内容宽高为0.接下来我们来看下无hack实现CSS三角形。 Clip-pathClip-path是CSS规范中的一个新的补充，它允许我们只显示一部分元素并隐藏其余元素。我们来看下它的工作原理：1&lt;div&gt;&lt;/div&gt;12345678div &#123; width: 200px; height: 200px; background: red; /* The points are: centered top, left bottom, right bottom */ clip-path: polygon(50% 0, 0 100%, 100% 100%);&#125;显示结果形状与上栗一样，可以看到我们需要一个polygon函数，要实现三角形需要三个点，我们先指定了div的宽高，这也是其重点，因为这样内容区域背景色我们就可以随心定制自己想要的，甚至也可以是图片。接下来可以看到在clip-path属性上调用polygon函数并给出了三个点的坐标，即三角形的上顶点和下面左右点的坐标，在图形定制方面就更加灵活了，我们可以实现各种各样的形状，拥有强大的灵活性。想要更多的形状实现可以参考这里 浏览器支持这个属性在Chrome中完美支持，ie就不用说了，并不支持，期待IE的未来吧。Safari需要使用-webkit-前缀，Firefox用户必须等到版本53。 更多内容请看这里 Danny Markovhttps://tutorialzine.com/2017/03/css-triangles-without-hacks]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>HTML/CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是作用域及js编译原理]]></title>
    <url>%2F2017%2F07%2F01%2F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8Ajs%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[每个程序语言都会有对变量的使用，会对这个变量就行赋值修改等操作。那么问题来了，这些变量都存在哪里，怎样对它进行查找并读取呢？显然，我们必须定义一套规则来操作这些变量简单的进行读取和存储，而这套规则应该就是作用域了。来看一个简单的赋值语句var a=2; 大多数人会认为这是一个声明变量并赋值而已，事实也确实如此，而要强调的是电脑中的引擎会将它认为是两个声明，第一个var a 看做是在编译器编译时处理，一个是a=2 在引擎运行时处理。通俗的话在概括下就是：为一个变量分配内存，将其命名为a，然后将值2保存进这个变量。当然在编译阶段还有很多任务要做，比如还要查看当前作用域是否声明过此变量等一系列问题。 来看一下如下简单代码： var a=2; console.log(a); 引擎是如何处理这段代码的呢？在当前作用域（当前也就是全局作用域）中，引擎会为变量a进行LHS查询和RHS查询。上面的代码var a=2; 会对a进行LHS查询，LHS查询也就是赋值操作的目标是谁。console.log(a) 中会对a进行RHS查询，可以这样理解RHS查询：谁是赋值操作的源头，也就是说这个变量a的源头是谁（值是谁），这里明显就是2了。 为什么要区分LHS和RHS查询呢？因为在变量还为声明的时候，这两种查询的行为不一样。来看如下代码： function foo(a){ console.log(b); //ReferenceError } foo(2); 可以看到在对b进行RHS查询时，变量b并未声明，此时引擎在当前作用域未找到变量b，然后会在外层作用域查找（此时为全局作用域），外层作用域都没有此变量，就会发生常见的ReferenceError。 而在看LHS查询，当LHS查询在此作用域和外层作用域都没有查找到此变量，全局作用域就会自动创建一个此变量，前提是在非严格模式下，如果在严格模式下会报ReferenceError。在ES5中引入的严格模式与正常模式相比在行为上有许多的不同。接下来若查找到此变量，而你要是对此变量做一些不合理的操作就会报TypeError错误。 在来看作用域，看如下代码： function foo(a){ console.log(a+b); } var b=2; foo(2); //4 可以看到引擎在执行foo函数作用域内的语句console.log（a+b）时b变量并未在此作用域内，而最后还是能输出4，从上面的讲述也已经提到了当引擎未在当前作用域查找到变量就会在它的上层作用域一层层的查找。而上面我们所手写的作用域叫做词法作用域，引擎在查找变量时会从内部的作用域一层层想外展开来，相应的如果内层的作用域中的变量与外层作用域声明的变量标识符一样的话，内部变量会覆盖外层的，但如果外层作用域是全局作用域可以通过Window.x 来访问，x为相应的变量标识符。]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>